# LINK RAYLIB HERE â†“
âŸ¨color, winâ‡window, dâ‡draw, key, mâ‡mouse, rayffiâŸ©â†râ†â€¢Import "../../rayed-bqn/raylib.bqn"
operators â† â€¢Import"./operations.bqn"
âŸ¨TextEditorâŸ© â† â€¢Import "./TextEditor.bqn"
âŸ¨RepeatKey, ErrorSafeâŸ© â† â€¢Import "./Utility.bqn"

theme  â† âŸ¨
	86â€¿156â€¿214	â‹ˆ"+-Ã—Ã·â‹†âˆšâŒŠâŒˆâˆ§âˆ¨Â¬|â‰¤<â‰¥>=â‰ â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!ğ”½ğ”¾ğ•Šğ•ğ•"
	79â€¿201â€¿176	â‹ˆ"ğ•—ğ•˜ğ•¤ğ•¨"
	204â€¿204â€¿204	â‹ˆ"Ë™ËœË˜Â¨âŒœâ¼`â†â‡â†©.;:?â€¢ğ•£â‹„,â†â‡â†©.;:?â€¢ğ•£â‹„,â€¿Â·"
	197â€¿134â€¿192	â‹ˆ"âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶âŠâ‰âš‡âŸ"
	255â€¿215â€¿0	â‹ˆ"{}âŸ¨âŸ©()[]"
	181â€¿206â€¿168	â‹ˆ"Â¯Ï€1234567890"
	106â€¿153â€¿85	â‹ˆ"#â€‹"
âŸ©
Col â† {ğ•Šchar: 0<â‰ indxâ†/{âˆ¨Â´char=1âŠ‘ğ•©}Â¨ theme ? âŠ‘indxâŠ‘theme ; 79â€¿201â€¿176 }

SHOW â† {xâ†â€¢Showğ•©, â€¢term.Flush@, x}
DSHOW â† {xâ†â€¢Show ğ•©, â€¢Show ğ•¨, â€¢term.Flush@, x}

curve â† {
	# points DrawFunction amplitudeâ€¿frequencyâ€¿phase_shift
	_GenNormalized â‡ {points Fn _ğ•£ ampâ€¿freqâ€¿ph_wh: # A normalised list of coords given a function
		âˆ¾âŸœ{ampÃ— Fn freqÃ— ph_wh+ ğ•©}Â¨ Ã·âŸœpoints â†•points+1
	}
	ReRange â‡ {âŸ¨from_sâ‹„from_eâŸ©â€¿âŸ¨to_sâ‹„to_eâŸ©ğ•Špoints: # sâ‰¡start â‹„ eâ‰¡end, only works on y
		0â€¿(to_s)âŠ¸+Â¨ 1â€¿(to_e-to_s)âŠ¸Ã—Â¨ 1â€¿(1Ã·(from_e-from_s))âŠ¸Ã—Â¨ +âŸœ0â€¿from_sÂ¨ points
	}
	Draw â‡ {[tlâ‹„br]â€¿colorâ€¿edge_colorâ€¿thickness ğ•Š points:
		Â·â€¿yâ†tl â‹„ Â·â€¿h â† tl+br-tl â‹„ câ†0
		{	# Folding over each point
			draw_dot â† 10<20|c+â†©1 # Simple counter for the dottet lines when out of bounds
			# Do the signs match eachther (it isn't a jump from one side to the other)
			on_edge â† (ğ•© â‰¡â—‹{Ã—-âŸœ(hÃ·2)1âŠ¸âŠ‘ğ•©} ğ•¨) âˆ§ (yâŠ¸â‰¡ âˆ¨ hâŠ¸â‰¡) 1âŠ‘ğ•¨  # Seeing if we have a minned or maxed point (out of bounds)
			(âŠ¢â—¶âŸ¨ color â‹„ edge_colorÃ—draw_dot âŸ© on_edge)â€¿thickness d.Line ğ•©â‰ğ•¨
			ğ•¨ # Returning the last point
		}Â´ (yâŠ¸âŒˆhâŠ¸âŒŠ)âŒ¾(1âŠ¸âŠ‘)Â¨ tlâŠ¸+Â¨ (br-tl)âŠ¸Ã—Â¨ points â‹„ points
	}

	# Curve genrators
	SIN â‡ {0.5+ Ã·âŸœ2 â€¢math.Sin ğ•©Ã—2Ã—Ï€}
	SAW â‡ {|1|ğ•©}
	TRI â‡ {|1-Ëœ2|2Ã—ğ•©}
	SQU â‡ {âŒŠ2|2Ã—ğ•©}
}

LFOInterface â† {ğ•Š:
	# Curve values
	freq â† 1
	phase_shift â† 0
	amp â† 0.4
	offset â† 0.5
	range â† 1

	# Utility values
	last_time â† â€¢MonoTime@
	ws â† wwâ€¿wh â† 400â€¿400 	# window size â† window_widthâ€¿window_height
	m_pos â† m.GetPos@
	val â† 0
	curve_coords â† â‹ˆ0
	window_offset â† -wsÃ—0.5â€¿Â¯0.1

	fnc â† âŠ‘ fncs â† curve.sinâ€¿curve.sawâ€¿curve.triâ€¿curve.squ
	fnc_name â† âŠ‘fnc_names â† "SIN"â€¿"SAW"â€¿"TRI"â€¿"SQU"

	Update â‡ {ğ•Š pos:
		xâ€¿y â† pos (10â€¿10âŠ¸âŒˆÂ·(ws-10â€¿10)âŠ¸âŒŠ+)â†© window_offset
		m_xâ€¿m_yâ†m_pos â‹„ lmxâ€¿lmy â† m_pos - pos # local mouse x â‹„ local mouse y

		delta â† last_time-Ëœâ€¢MonoTime@ â‹„ last_time â†© â€¢MonoTime@
		# Looping phase_shift one whole loop of the curve
		phase_shift â†© {phase_shiftâ‰¥ 1Ã·freq ? delta ; phase_shift+delta}

		# Changing the function or range
		{ğ•Š: fnc_name â†© âŠ‘fnc_names 1âŠ¸âŒ½â†© â‹„ fnc â†© âŠ‘fncs 1âŠ¸âŒ½â†© }âŸkey.IsPressed key.space
		{0â‰¢vâ†(Ã—Ã—(âŒˆ|)) m.WheelMovedâŸ¨âŸ© ? range |âˆ˜+â†©v;@}

		m_pos â†© m.GetPos@

		amp â†© -2Ã— (lmy-(whÃ·2)) Ã· wh # amplitude mouse_y from center
		freq â†© 10000âŒŠ wwÃ·lmx # Frequency limited to 10000

		# Calculating points of the curve
		curve_coords â†© (500âŒŠ|âŒŠwwÃ—freq) Fnc curve._GenNormalized ampâ€¿freqâ€¿phase_shift
		val â†© 1âŠ‘âŠ‘curve_coords # The first point in the curve is our value
	}

	GetFormula â‡ {ğ•Š: ("("âˆ¾(â€¢FMT Ã·âŸœ10âŒŠ10Ã—amp)âˆ¾"Ã— "âˆ¾(â€¢FMT Ã·âŸœ10âŒŠ10Ã—offset)âˆ¾"+ "âˆ¾fnc_nameâˆ¾" time +"âˆ¾(â€¢Fmt Ã·âŸœ10âŒŠ10Ã—freq)âˆ¾")")}
	Draw â‡ {ğ•Š pos:
		xâ€¿y â† pos (10â€¿10âŠ¸âŒˆÂ·(ws-10â€¿10)âŠ¸âŒŠ+)â†© window_offset

		# The backdrop
		color.black d.Rectangle pos (âŠ£â‰+) wwâ€¿wh

		# Drawing the curve!
		mapped_coords â† âŸ¨0â€¿amp â‹„ offset (-â‰+) Ã·âŸœrange ampÃ·2âŸ© curve.ReRange curve_coords
		[pos â‹„ pos+ws]â€¿color.redâ€¿color.grayâ€¿3 curve.Draw mapped_coords

		# {ğ•Ši: color.gray d.Rectangle (xâ€¿(y+whÃ—i)) (âŠ£â‰+) wwâ€¿1 }Â¨ Ã·âŸœ(rangeÃ·5)â†•âŒŠrangeÃ·5 #SHOW Ã·âŸœrange â†• |âŒˆ range
		# {ğ•Ši: color.gray d.Rectangle (xâ€¿(y+ whÃ—i )) (âŠ£â‰+) wwâ€¿2 }Â¨ â‹ˆoffset

		# The number you see in the center
		color.whiteâ€¿fontâ€¿30 d.Text (âŒŠpos + Ã·âŸœ2 wwâ€¿wh)â€¿(â€¢FMT Ã·âŸœ100âŒŠ100Ã—val)

		# The circle on the left moving with the curve
		val_y â† (whÃ·2)+ y+ whÃ— val - (ampÃ·2)
		(âŠ¢â—¶âŸ¨color.redâ‹„color.grayâŸ© (yâŠ¸>âˆ¨(y+wh)âŠ¸<) val_y) d.Ellipse |âŒŠxâ€¿(yâŒˆ(y+wh)âŒŠ val_y) (-â‰+) 10â€¿10

		# The formula in the bottom
		color.whiteâ€¿fontâ€¿20 d.Text ((x-ww)â€¿y+wh+10)â€¿(GetFormula@)
	}
}

DynamicNums â† {ğ•Šeâ€¿char_size:
	lfoChooser â† LFOInterface@
	type â† âŠ‘ nothingâ€¿shiftâ€¿lfo â† {ğ•Š:â‡}Â¨â†•3

	IsNmbr â† {+Â´Ë˜ ğ•© =âŒœ "Â¯."âˆ¾'0'+â†•10}
	GetNmbr â† {ğ•Štâ€¿c:
		start â† c - +Â´âˆ§` IsNmbr âŒ½ c âŒ½ t # Start index of the number
		length â† +Â´âˆ§` IsNmbr start âŒ½ t # Length of the number
		startâ€¿length
	}

	startâ€¿length â† 0â€¿0
	m_down_pos â† 0â€¿0
	down_val â† 0
	m_press â† 0

	Update â‡ { ğ•Š tâ€¿c:
		m_down â† m.IsButtonDown m.button.left
		m_pos â† m.GetPos@

		{rayffi.IsMouseButtonPressed 0 ?
			type â†© {key.IsDown key.left_shift ? shift ; key.IsDown key.left_control ? lfo ; nothing};
			m_press â†© 1
		@}

		{m_down ? m_press â†© 0 â‹„ typeâ‰¢nothing ? âŠ‘IsNmbr â‹ˆcâŠ‘t ?
			startâ€¿length â†© GetNmbr tâ€¿c
			# Data that stays consistent during the interaction (that only gets calculated the first frame)
			{m_press ?
				m_down_pos â†© m_pos
				down_val â†© â€¢ParseFloat {'Â¯'â‰¡ğ•©?'-';ğ•©}Â¨ lengthâ†‘startâŒ½t
			;@}

			# Get the new value
			new_nmbr â† {
				type â‰¡ shift?
					â€¢FMT Ã·âŸœ10âŒˆ10Ã— down_val+ 0.1Ã— (âŠ‘m_pos) - âŠ‘m_down_pos
				; type â‰¡ lfo ?
					â€¢FMT Ã·âŸœ100âŒŠ100Ã— lfoChooser.Update m_down_pos
				; â€¢FMT down_val
			}

			# Replace the number with the new number and move the cursor to the start
			tâ€¿câ†© âŸ¨{new_nmbr âˆ¾ lengthâ†“ğ•©}âŒ¾(startâŠ¸âŒ½) t â‹„ startâŸ©
			tâ€¿c

		; rayffi.IsMouseButtonReleased 0 ? type â‰¡ lfo ?
			startâ€¿length â† GetNmbr tâ€¿c
			formula â† lfoChooser.GetFormula@
			âŸ¨{formula âˆ¾ lengthâ†“ğ•©}âŒ¾(startâŠ¸âŒ½) t â‹„ startâŸ©
		; tâ€¿c }
	}

	Draw â‡ {ğ•Štâ€¿c:
		{m.IsButtonDown m.button.left ? type â‰¡ lfo ?
			lfoChooser.Draw m_down_pos
		;@}
		{(typeâ‰¡lfo) âˆ¨ typeâ‰¡shift ?
			xy â† e.CursorXY tâ€¿start
			color.gray d.Rectangle â€¢SHow âŒŠ(xyÃ—char_size) (âŠ£â‰+) (xy+0â€¿(lengthÃ—1âŠ‘char_size)Ã—char_size)
		;@}
	}
}

RaylibTextEditor â† {ğ•Š âŸ¨font â‹„ font_size â‹„ default_textâŸ©:
	GetCharSize â† 1â€¿0.5âŠ¸Ã—
	char_size â† GetCharSize font_size

	# The details you can change about the editor
	chars â† {cursorâ€¿enterâ€¿select â‡ '_'â€¿(@+10)â€¿'_'}
	skip_chars â† (@+48+â†•10)âˆ¾"._"âˆ¾@+(32âŠ¸+âˆ¾âŠ¢)65â†“â†•91

	# Our instance of the editor
	e â† TextEditor charsâ€¿skip_chars

	dynNums â† DynamicNums eâ€¿char_size

	# THE local data used to update the editor
	Buffer â† {ğ•Š initialâ€¿size:
		bufferâ†âŸ¨initialâŸ© â‹„ forward_bufferâ†âŸ¨âŸ©
		Add â‡ {S: buffer (â‹ˆğ•©)âŠ¸âˆ¾ â†© â‹„ forward_buffer â†© (âŸ¨âŸ©) â‹„ { size<â‰ buffer ? buffer 1âŠ¸â†“âŒ¾âŒ½â†© ; @} }
		Redo â‡ {ğ•Š: 0<â‰ forward_buffer ? buffer â†© â‹ˆâŠ‘forward_buffer â‹„ forward_buffer 1âŠ¸â†“ â†© ; @ }
		Undo â‡ {ğ•Š: 1<â‰ buffer ? forward_buffer (â‹ˆâŠ‘buffer)âŠ¸âˆ¾â†© â‹„ buffer 1âŠ¸â†“â†© ; @}
		Current â‡ {ğ•Š: âŠ‘buffer }
	}
	b â† Buffer âŸ¨default_textâ€¿0, 200âŸ©

	# Makking a very hacky tool to instantiates a whole bunch of repeaters. Like a revolver it'll do rounds!
	# I make sure! I use up all my repeaters each frame so the next frame everyone will get back the some one
	RepeatKeys â† {amountğ•Štimings: keys â† RepeatKeyÂ¨ amountâ¥Šâ‹ˆtimings, Do â‡ {ğ•Šv: keys 1âŠ¸âŒ½â†©, (âŠ‘keys).Do v}}
	buffer_repeats â† 2 RepeatKeys 0.5â€¿0.05
	Update â‡ {ğ•Š:
		{ğ•Š: char_size â†© GetCharSize font_size +â†© 0.5  }âŸ((key.IsDown key.left_super) âˆ§ key.IsDown key.equal)@
		{ğ•Š: char_size â†© GetCharSize font_size -â†© 0.5 }âŸ((key.IsDown key.left_super) âˆ§ key.IsDown key.minus)@
		update â† 0
		{b.Addğ•©â‹„updateâ†©1}âŸ(â‰¢âŸœlast) React last â† b.Current@
		b.UndoâŸ(buffer_repeats.Do (1â€¿0 â‰¡ key.IsDownÂ¨ key.left_superâ€¿key.left_shift) âˆ§ key.IsDown key.z)@
		b.RedoâŸ(buffer_repeats.Do (âˆ§Â´ key.IsDownÂ¨ key.left_shiftâ€¿key.left_super) âˆ§ key.IsDown key.z)@
		update
	}
	Output â‡ {ğ•Š: Draw b.Current@ }
	Get â‡ {ğ•Š: âŠ‘b.Current@ }

	repeats â† 7 RepeatKeys 0.5â€¿0.05
	React â† {ğ•Š tâ€¿c:
		tâ€¿c dynNums.Update â†©

		# Typing chars!
		tâ€¿c e.TypeâŸ(@â‰¢âŠ£)Ëœ â†© key.PressedChar @

		# Moving cursor to where you clicked
		{ğ•Š:c â†© (âŒŠ(m.GetPos@)Ã·âŒ½char_size) e.XYCursor t}âŸrayffi.IsMouseButtonPressed 0

		remove_amount â† |{key.IsDown key.left_alt ? Â¯1 e.Scope tâ€¿c ; key.IsDown key.left_super ? Â¯1â€¿0 e.Bounds tâ€¿c ; 1}
		tâ€¿c e.Remove âŸ(repeats.Do key.IsDown key.backspace)Ëœ â†© remove_amount
		# tâ€¿c e.Remove âŸ(repeats.Do key.IsDown key.delete)Ëœ â†© -remove_amount
		tâ€¿c e.Tab	âŸ(repeats.Do key.IsPressed key.tab) â†©
		tâ€¿c e.Enter âŸ(repeats.Do 1â€¿0 â‰¡ key.IsDownÂ¨ key.enterâ€¿key.left_super) â†©

		# All the things to do with the arrow keys
		{ğ•Šdirection:
			{(âˆ§Â´ key.IsDownÂ¨ key.left_altâ€¿key.left_super) ? tâ€¿c e.SwapËœ â†© direction
			; (key.IsDown key.left_alt âˆ§ 0â‰¡âŠ‘direction) ? tâ€¿c e.SwapËœ â†© direction
			;	direction Ã—â†© |{key.IsDown key.left_alt ?
					(âŠ‘direction) e.Scope tâ€¿c
				; key.IsDown key.left_super ?
					direction e.Bounds tâ€¿c
				; 1 }
				câ†© tâ€¿c e.MoveËœ direction
			}
		}Â¨ âŠ‘âŸœâŸ¨1â€¿0 â‹„ 0â€¿1 â‹„ Â¯1â€¿0 â‹„ 0â€¿Â¯1âŸ©Â¨ / repeatsâŠ¸{ğ•¨.Do ğ•©}Â¨ key.IsDownÂ¨ key.rightâ€¿key.downâ€¿key.leftâ€¿key.up

		# Copy pasta
		(r.clipboard.Setâˆ˜e.Line tâ€¿cË™)âŸ((key.IsDown key.left_super) âˆ§ (âˆ¨Â´ key.IsPressedÂ¨ key.câ€¿key.x))@
		{tâ€¿c e.AddLineËœ â†© ğ•©}âˆ˜r.clipboard.GetâŸ((key.IsDown key.left_super) âˆ§ key.IsPressed key.v)@
		(r.clipboard.Setâˆ˜e.Line tâ€¿cË™)âŸ((key.IsDown key.left_super) âˆ§ key.IsPressed key.c)@
		{ğ•Š: tâ€¿c e.RemoveLine â†©}âŸ((key.IsDown key.left_super) âˆ§ key.IsPressed key.x)@

		("./save.bqn"âŠ¸â€¢file.Chars tË™)âŸ((key.IsDown key.left_super) âˆ§ key.IsPressed key.s)@
		tâ€¿c
	}

	clock â† r.StartClock@
	Draw â† {ğ•Štâ€¿c:
		("text is not a string: "â‹ˆt) { ğ•¨!1â‰¡â‰¡ğ•© â‹„ ğ•¨! âˆ§Â´{2â‰¡â€¢Typeğ•©}Â¨ğ•©} t
		# Drawing background
		char_sizeâŠ¸{ch_hâ€¿ch_wğ•Šyâ€¿length: (32â€¿32â€¿32â€¿200) d.Rectangle âŸ¨0â‹„yÃ—ch_hâŸ© (âŠ£â‰+) âŸ¨lengthÃ—ch_wâ‹„ch_hâŸ© }Â¨ ((â†•â‰ ) âˆ¾Â¨ â‰ Â¨) chars.enter e.Split t
		DrawLines chars.enter e.Split t

		((e.CursorXY tâ€¿c)âˆ¾â‹ˆ(204â€¿204â€¿204â€¿255))âŠ¸DrawCharâŸœchars.cursorâŸ(0.2<1|clock.TimeâŸ¨âŸ©)@

		dynNums.Draw tâ€¿c
		# {(ğ•© CursorXY text) DrawChar ch.select}Â¨âŸ(>âŸœ1â‰ ) ((âŠ‘âˆ§)+(â†•Â·Â¬Â´âˆ¨)) cursorâ€¿select_start
	}
	DrawLines â† {
		ğ•Šlines: (â†•â‰ lines) {yğ•Šline: (â†•â‰ line) {xğ•Šch: xâ€¿yâ€¿(âˆ¾âŸœ255 Col ch) DrawChar ch}Â¨ line }Â¨ lines;
		colorğ•Šlines: lines â‹„ (â†•â‰ lines) {yğ•Šline: (â†•â‰ line) {xğ•Šch: xâ€¿yâ€¿color DrawChar ch}Â¨ line }Â¨ lines
	}
	DrawChar â† {xâ€¿yâ€¿colorğ•Šchar: colorâ€¿fontâ€¿font_size d.Text âŸ¨âŒŠâŒ½(yâ€¿x)Ã—char_size, â‹ˆcharâŸ© }
}

font â† @
_Start â† { Update _ğ•£ ğ•©:
	win.SetSize w_size â† 1200â€¿1200
	font â†© r.font.LoadBQN 300 #â‹„ win.SetPos Â¯2000â€¿Â¯900
	editor â† RaylibTextEditor fontâ€¿30â€¿(â€¢file.Chars "./save.bqn")

	Update editorâ€¿âŸ¨@â‹„@âŸ©â€¿1
}

DressUp â† {ğ•Štext:
	Replace â† {findâ€¿replaceğ•Šstr: {âˆ¨Â´findâ·str ? âˆ¾{findâ‰¡ğ•©? replace ; ğ•©}Â¨ str ; str} }

	# Add flushed show function
	# text ("print_storeâ‡"""" â‹„ Show â† { print_store âˆ¾âŸœ('â‹„'âˆ¾ğ•©)â†© }"âˆ¾(@+10))âŠ¸âˆ¾â†©

	# Safe pick
	text 'âŠ‘'â€¿"(|ËœâŸœâ‰ âŠ‘âŠ¢)"âŠ¸Replace â†©

	# Short hand for random
	text 'â•'â€¿"â€¢rand.Range "âŠ¸Replace â†©
}

DrawShapes â† {
	ğ•ŠâŸ¨'r' â‹„ data â‹„ câŸ©:
		c d.Rectangle âŒŠdata;
	ğ•ŠâŸ¨'e' â‹„ data â‹„ câŸ©:
		c d.Ellipse âŒŠdata;
	ğ•ŠâŸ¨'t' â‹„ data â‹„ câŸ©:Ëœ
		c d.Triangle âŒŠdata ;
	ğ•ŠâŸ¨'l' â‹„ data â‹„ câŸ©:
	@
		# c d.Line âŒŠdata
}


parseâ€¿callâ€¿getâ€¿draw â† ErrorSafeÂ¨ "Parse: "â€¿"Call: "â€¿"Update: "â€¿"Draw: "
clock â† r.StartClock @

DrawError â† {color.redâ€¿fontâ€¿20 d.Text (0â€¿0.85Ã—win.GetSize@)â€¿ğ•©}
Update â† {ğ•Š editorâ€¿codeâ€¿changed:
	clock.TickâŸ¨âŸ©
	{changed âˆ¨ (key.IsDown key.left_super) âˆ§ key.IsPressed key.enter ?
		code â†© âŸ¨@â‹„DressUp editor.Get@âŸ©
		code â€¢BQN parse._try â†©
		code {ğ• âŸ¨color, win.GetSize@, operators, curveâŸ©} call._try â†©
	; @}

	objs â† {ğ•©.Get clock.Time@} get._try code
	err â† DrawShapesÂ¨ draw._try objs
	DrawErrorâŸ(â‰¢âŸœ@) âŠ‘err

	changed â†© editor.UpdateâŸ¨âŸ©
	editor.OutputâŸ¨âŸ©

	editorâ€¿codeâ€¿changed
} d._withCanvas_ 32â€¿32â€¿32â€¿255

Update â€¢_While_ (Â¬win.ShouldClose) _Start win._openAs "editor"
