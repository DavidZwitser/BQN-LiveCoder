# start clock then tick at the start of every frame to get accurate clock.delta and clock.time
StartClock â† {ğ•Š@:
  startTime â‡ â€¢MonoTime@
  Time  â‡ {ğ•Š:startTime-Ëœâ€¢Monotime@}
}
clock â† StartClock@

LFO â‡ {
	ğ•Šstepâ€¿size: Ã—âŸœsize Ã·âŸœ2 â€¢math.Sin Ã—âŸœ(clock.TimeâŸ¨âŸ©) Ã—âŸœstep Ï€Ã·2;
	ğ•Šstep: 			  Ã·âŸœ2 â€¢math.Sin Ã—âŸœ(clock.TimeâŸ¨âŸ©) Ã—âŸœstep Ï€Ã·2
}

Tile â‡ {ğ•Š sizeâ€¿amount:
	amount |â†©
	el_count â† {1<â‰ amount ? amount ;
		short_axis_amount â† amountÃ—Ã·Â´âˆ§size
		âŒ½âŸ(>Â´size) short_axis_amountâˆ¾amount
	}
	el_size â† sizeÃ·el_count
	âˆ§Ë˜âŒ¾â‰Â¨ {(el_size Ã— ğ•©) (âŠ£â‰+) el_size}Â¨ â†•âŒˆel_count
}

Center â‡ {ws ğ•Š ell:
	ell_size â† (Â¯1âŠ(Â¯1â€¿Â¯1)âŠ‘ell)-(tlâ†âŠâŠ‘ell) # bottom_right - top_left
	ell_center â† tl + ell_sizeÃ·2
	move_vec â† â‰Ëœ(wsÃ·2) - ell_center
	{ğ•© + move_vec}Â¨ ell
}

Square â‡ {ğ•Šell:
	{-Â´-ËâŒ½ğ•©}âŠ¸{ # Get the diff of the side that is too large (- meaning y is to large + meaning x is too large)
		offâ†Ã·âŸœ2|ğ•¨ # The amount each corner should move
		(ğ•©) + âŒ½Ë˜âŸ(ğ•¨<0) [offâ€¿0â‹„(-off)â€¿0] # âŒ½Ë˜ if we're dealing with y's
	}Â¨ ell # First untangeling the shape (fixing top left and top right
}

Scale â‡ {scaleğ•Šell:
	{
		center â† Ã·âŸœ2 +Ë ğ•©
		size â† scale Ã— -ËâŒ½ ğ•©
		center (-â‰+) Ã·âŸœ2 size
	}Â¨ ell
}

Shape â‡ {ğ•Š shapesâ€¿ellementsâ€¿colors:
	{ğ•Šlength: lengthâŠ¸(|ËœâŸœâ‰ âŠ‘âŠ¢)Â¨ âŸ¨shapes â‹„ â¥Šellements â‹„ colorsâŸ© }Â¨ â†•âŠ‘âˆ¨â‰ Â¨ â¥ŠÂ¨ ğ•©
}
